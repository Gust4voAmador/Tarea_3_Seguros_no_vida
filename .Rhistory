prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, max_x))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Convolución p*2(x) inicial
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Convoluciones sucesivas p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades P(N = n) ~ Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Cálculo de fs(x)
for (i in 1:(max_x + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos columna x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas dinámicamente
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Calcular tamaño máximo de la convolución (valor máximo posible de S)
max_x <- n * length(prob_montos)
# Crear el data.frame vacío
df_convolucion <- as.data.frame(matrix(0, nrow = max_x + 1 , ncol = length(n+1)))
colnames(df_convolucion) <- columnas
df_convolucion[["x"]] <- 0:max_x
# Ajustar p(x)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, max_x))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Convolución p*2(x) inicial
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Convoluciones sucesivas p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades P(N = n) ~ Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Cálculo de fs(x)
for (i in 1:(max_x + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos columna x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas dinámicamente
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Calcular tamaño máximo de la convolución (valor máximo posible de S)
max_x <- n * length(prob_montos)
# Crear el data.frame vacío
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1 , ncol = length(columnas)))
colnames(df_convolucion) <- columnas
df_convolucion[["x"]] <- 0:max_x
# Ajustar p(x)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, max_x))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Convolución p*2(x) inicial
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Convoluciones sucesivas p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades P(N = n) ~ Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Cálculo de fs(x)
for (i in 1:(max_x + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos columna x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas dinámicamente
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Calcular tamaño máximo de la convolución (valor máximo posible de S)
max_x <- n * length(prob_montos)
# Crear el data.frame vacío
df_convolucion <- as.data.frame(matrix(0, nrow = max_x + 1 , ncol = length(columnas)))
colnames(df_convolucion) <- columnas
df_convolucion[["x"]] <- 0:max_x
# Ajustar p(x)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, max_x))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Convolución p*2(x) inicial
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Convoluciones sucesivas p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades P(N = n) ~ Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Cálculo de fs(x)
for (i in 1:(max_x + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos columna x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Crear el data.frame con n+1 filas
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1, ncol = length(columnas)))
colnames(df_convolucion) <- columnas
# Indexar columna x
df_convolucion[["x"]] <- 0:n
# Ajustar p(x) (agregar cero al inicio)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, n))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Calcular p*2(x)
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Calcular p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades de Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Calcular fs(x)
for (i in 1:(n + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Crear el data.frame con n+1 filas
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1, ncol = length(columnas)))
colnames(df_convolucion) <- columnas
# Indexar columna x
df_convolucion[["x"]] <- 0:n
# Ajustar p(x) (agregar cero al inicio)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, n))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Calcular p*2(x)
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Calcular p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades de Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Calcular fs(x)
for (i in 1:(n + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 5)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Crear el data.frame con n+1 filas
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1, ncol = length(columnas)))
colnames(df_convolucion) <- columnas
# Indexar columna x
df_convolucion[["x"]] <- 0:n
# Ajustar p(x) (agregar cero al inicio)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, n))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Calcular p*2(x)
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Calcular p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades de Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Calcular fs(x)
for (i in 1:(n + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 8)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Crear el data.frame con n+1 filas
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1, ncol = length(columnas)))
colnames(df_convolucion) <- columnas
# Indexar columna x
df_convolucion[["x"]] <- 0:n
# Ajustar p(x) (agregar cero al inicio)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, n))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Calcular p*2(x)
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Calcular p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades de Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Calcular fs(x)
for (i in 1:(n + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 20)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Crear el data.frame con n+1 filas
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1, ncol = length(columnas)))
colnames(df_convolucion) <- columnas
# Llenar el dataframe
df_convolucion[["x"]] <- 0:n
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, n))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Calcular p*2(x)
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Calcular p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades de Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Calcular fs(x)
for (i in 1:(n + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 20)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Crear el data.frame con n+1 filas
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1, ncol = length(columnas)))
colnames(df_convolucion) <- columnas
# Llenar el dataframe
df_convolucion[["x"]] <- 0:n
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, n))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Calcular p*2(x)
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Calcular p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades de Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Calcular fs(x)
for (i in 1:(n + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
print(pepe)
setwd("C:/Users/AMADOR/OneDrive - Universidad de Costa Rica/I-2025/Seguros de no-vida/Tarea 3 Seguros no vida")
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
combinacion_suma <- function(vec1, vec2, indice_df) { #donde x es indice
suma <- 0
if (indice_df == 0) {
suma <- vec1[1] * vec2[1]
return(suma)
}
else {
for (i in 0:indice_df) {
suma <- suma + vec1[1 + i] * vec2[(indice_df + 1) - i]
}
return(suma)
}
}
convoluciador <- function(vec_conv1, vec_conv2){
# Creación de vector para guardar los resultados de los productos
vec_nueva_conv <- vector(mode = "numeric", length = length(vec_conv1))
for (i in 1:length(vec_conv1)) {
indice= i-1
vec_nueva_conv[i] <- combinacion_suma(vec_conv1, vec_conv2, indice)
}
return(vec_nueva_conv)
}
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Crear el data.frame con n+1 filas
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1, ncol = length(columnas)))
colnames(df_convolucion) <- columnas
# Llenar el dataframe
df_convolucion[["x"]] <- 0:n
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, n))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Calcular p*2(x)
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Calcular p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades de Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Calcular fs(x)
for (i in 1:(n + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
print(pepe)
# --- Paso 1: Distribuciones transformadas ---
poisson_transformada <- function(lambda, salto, max_valor) {
vec <- rep(0, max_valor + 1)
for (n in 0:(max_valor %/% salto)) {
x <- n * salto
if (x <= max_valor) {
vec[x + 1] <- dpois(n, lambda)
}
}
return(vec)
}
# --- Paso 2: Método alternativo con tabla detallada ---
metodo_alternativo_con_tabla <- function(lambda_total, probs, max_valor) {
lambdas <- lambda_total * probs
saltos <- c(1, 2, 3)
# Calcular distribuciones individuales transformadas
dist1 <- poisson_transformada(lambdas[1], saltos[1], max_valor)
dist2 <- poisson_transformada(lambdas[2], saltos[2], max_valor)
dist3 <- poisson_transformada(lambdas[3], saltos[3], max_valor)
# Calcular convolución N1 + 2N2
conv_12 <- convoluciador(dist1, dist2)
# Calcular convolución final: N1 + 2N2 + 3N3
conv_123 <- convoluciador(conv_12, dist3)
# Construir tabla estilo libro
df <- data.frame(
x = 0:max_valor,
`Pr(1N1 = x)` = dist1,
`Pr(2N2 = x)` = dist2,
`Pr(3N3 = x)` = dist3,
`Pr(N1 + 2N2 = x)` = conv_12,
`f_s(x)` = conv_123
)
return(df)
}
# --- Ejecutar la función ---
resultado_detallado <- metodo_alternativo_con_tabla(
lambda_total = 0.8,
probs = c(0.25, 0.375, 0.375),
max_valor = 6
)
print(resultado_detallado)
combinacion_suma <- function(vec1, vec2, indice_df) { #donde x es indice
suma <- 0
if (indice_df == 0) {
suma <- vec1[1] * vec2[1]
return(suma)
}
else {
for (i in 0:indice_df) {
suma <- suma + vec1[1 + i] * vec2[(indice_df + 1) - i]
}
return(suma)
}
}
convoluciador <- function(vec_conv1, vec_conv2){
# Creación de vector para guardar los resultados de los productos
vec_nueva_conv <- vector(mode = "numeric", length = length(vec_conv1))
for (i in 1:length(vec_conv1)) {
indice= i-1
vec_nueva_conv[i] <- combinacion_suma(vec_conv1, vec_conv2, indice)
}
return(vec_nueva_conv)
}
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Crear el data.frame con n+1 filas
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1, ncol = length(columnas)))
colnames(df_convolucion) <- columnas
# Llenar el dataframe
df_convolucion[["x"]] <- 0:n
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, n))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Calcular p*2(x)
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Calcular p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades de Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Calcular fs(x)
for (i in 1:(n + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
print(pepe)
# --- Paso 1: Distribuciones transformadas ---
poisson_transformada <- function(lambda, salto, max_valor) {
vec <- rep(0, max_valor + 1)
for (n in 0:(max_valor %/% salto)) {
x <- n * salto
if (x <= max_valor) {
vec[x + 1] <- dpois(n, lambda)
}
}
return(vec)
}
# --- Paso 2: Método alternativo con tabla detallada ---
metodo_alternativo_con_tabla <- function(lambda_total, probs, max_valor) {
lambdas <- lambda_total * probs
saltos <- c(1, 2, 3)
# Calcular distribuciones individuales transformadas
dist1 <- poisson_transformada(lambdas[1], saltos[1], max_valor)
dist2 <- poisson_transformada(lambdas[2], saltos[2], max_valor)
dist3 <- poisson_transformada(lambdas[3], saltos[3], max_valor)
# Calcular convolución N1 + 2N2
conv_12 <- convoluciador(dist1, dist2)
# Calcular convolución final: N1 + 2N2 + 3N3
conv_123 <- convoluciador(conv_12, dist3)
# Construir tabla estilo libro
df <- data.frame(
x = 0:max_valor,
`Pr(1N1 = x)` = dist1,
`Pr(2N2 = x)` = dist2,
`Pr(3N3 = x)` = dist3,
`Pr(N1 + 2N2 = x)` = conv_12,
`f_s(x)` = conv_123
)
return(df)
}
# --- Ejecutar la función ---
resultado_detallado <- metodo_alternativo_con_tabla(
lambda_total = 0.8,
probs = c(0.25, 0.375, 0.375),
max_valor = 6
)
print(resultado_detallado)
