df_convolucion[["p*2(x)"]] <- convoluciador(c(0, 0.25, 0.375, 0.375,0,0,0),c(0, 0.25, 0.375, 0.375,0,0,0))
# Realizar las convoluciones
for (i in 5:(n+2)) {
a <- i-1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
#Vector de probabilidades de N donde esta es poisson(lambda)
vec_prob_N <- vector(mode = "numeric", length = n+1)
for (i in 0:n) {
vec_prob_N[i+1] <- exp(-lambda) * (lambda)^(i) * (1/factorial(i))
}
# Cálculo de función de masa de probabilidad
for (i in 1:(n+1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 7)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos # definir n según la entrada
# Crear los nombres de columnas
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Crear el data.frame vacío
df_convolucion <- as.data.frame(matrix(0, nrow = n+1 , ncol = length(columnas)))
# Llenar el dataframe
indice <- c(0:n)
prob_montos <- c(0, prob_montos)
colnames(df_convolucion) <- columnas
df_convolucion[["x"]] <- indice
df_convolucion[["p*0(x)"]] <- c(1, rep(0,n))
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos
# Se realiza convolucion 2 que es P*2(x)
df_convolucion[["p*2(x)"]] <- convoluciador(c(0, 0.25, 0.375, 0.375,0,0,0),c(0, 0.25, 0.375, 0.375,0,0,0))
# Realizar las convoluciones
for (i in 5:(n+2)) {
a <- i-1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
#Vector de probabilidades de N donde esta es poisson(lambda)
vec_prob_N <- vector(mode = "numeric", length = n+1)
for (i in 0:n) {
vec_prob_N[i+1] <- exp(-lambda) * (lambda)^(i) * (1/factorial(i))
}
# Cálculo de función de masa de probabilidad
for (i in 1:(n+1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas dinámicamente
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Calcular tamaño máximo de la convolución (valor máximo posible de S)
max_x <- n * length(prob_montos)
# Crear el data.frame vacío
df_convolucion <- as.data.frame(matrix(0, nrow = max_x + 1 , ncol = length(columnas)))
colnames(df_convolucion) <- columnas
df_convolucion[["x"]] <- 0:max_x
# Ajustar p(x)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, max_x))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Convolución p*2(x) inicial
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Convoluciones sucesivas p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades P(N = n) ~ Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Cálculo de fs(x)
for (i in 1:(max_x + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos columna x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas dinámicamente
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Calcular tamaño máximo de la convolución (valor máximo posible de S)
max_x <- n * length(prob_montos)
# Crear el data.frame vacío
df_convolucion <- as.data.frame(matrix(0, nrow = max_x + 1 , ncol = length(columnas)))
colnames(df_convolucion) <- columnas
df_convolucion[["x"]] <- 0:max_x
# Ajustar p(x)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, max_x))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Convolución p*2(x) inicial
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Convoluciones sucesivas p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades P(N = n) ~ Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Cálculo de fs(x)
for (i in 1:(max_x + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos columna x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 5)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas dinámicamente
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Calcular tamaño máximo de la convolución (valor máximo posible de S)
max_x <- n * length(prob_montos)
# Crear el data.frame vacío
df_convolucion <- as.data.frame(matrix(0, nrow = max_x + 1 , ncol = length(columnas)))
colnames(df_convolucion) <- columnas
df_convolucion[["x"]] <- 0:max_x
# Ajustar p(x)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, max_x))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Convolución p*2(x) inicial
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Convoluciones sucesivas p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades P(N = n) ~ Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Cálculo de fs(x)
for (i in 1:(max_x + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos columna x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas dinámicamente
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Calcular tamaño máximo de la convolución (valor máximo posible de S)
max_x <- n * length(prob_montos)
# Crear el data.frame vacío
df_convolucion <- as.data.frame(matrix(0, nrow = max_x + 1 , ncol = length(n+1)))
colnames(df_convolucion) <- columnas
df_convolucion[["x"]] <- 0:max_x
# Ajustar p(x)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, max_x))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Convolución p*2(x) inicial
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Convoluciones sucesivas p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades P(N = n) ~ Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Cálculo de fs(x)
for (i in 1:(max_x + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos columna x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas dinámicamente
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Calcular tamaño máximo de la convolución (valor máximo posible de S)
max_x <- n * length(prob_montos)
# Crear el data.frame vacío
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1 , ncol = length(columnas)))
colnames(df_convolucion) <- columnas
df_convolucion[["x"]] <- 0:max_x
# Ajustar p(x)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, max_x))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Convolución p*2(x) inicial
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Convoluciones sucesivas p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades P(N = n) ~ Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Cálculo de fs(x)
for (i in 1:(max_x + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos columna x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas dinámicamente
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Calcular tamaño máximo de la convolución (valor máximo posible de S)
max_x <- n * length(prob_montos)
# Crear el data.frame vacío
df_convolucion <- as.data.frame(matrix(0, nrow = max_x + 1 , ncol = length(columnas)))
colnames(df_convolucion) <- columnas
df_convolucion[["x"]] <- 0:max_x
# Ajustar p(x)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, max_x))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Convolución p*2(x) inicial
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Convoluciones sucesivas p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades P(N = n) ~ Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Cálculo de fs(x)
for (i in 1:(max_x + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos columna x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Crear el data.frame con n+1 filas
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1, ncol = length(columnas)))
colnames(df_convolucion) <- columnas
# Indexar columna x
df_convolucion[["x"]] <- 0:n
# Ajustar p(x) (agregar cero al inicio)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, n))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Calcular p*2(x)
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Calcular p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades de Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Calcular fs(x)
for (i in 1:(n + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Crear el data.frame con n+1 filas
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1, ncol = length(columnas)))
colnames(df_convolucion) <- columnas
# Indexar columna x
df_convolucion[["x"]] <- 0:n
# Ajustar p(x) (agregar cero al inicio)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, n))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Calcular p*2(x)
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Calcular p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades de Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Calcular fs(x)
for (i in 1:(n + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 5)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Crear el data.frame con n+1 filas
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1, ncol = length(columnas)))
colnames(df_convolucion) <- columnas
# Indexar columna x
df_convolucion[["x"]] <- 0:n
# Ajustar p(x) (agregar cero al inicio)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, n))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Calcular p*2(x)
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Calcular p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades de Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Calcular fs(x)
for (i in 1:(n + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 8)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Crear el data.frame con n+1 filas
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1, ncol = length(columnas)))
colnames(df_convolucion) <- columnas
# Indexar columna x
df_convolucion[["x"]] <- 0:n
# Ajustar p(x) (agregar cero al inicio)
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, n))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Calcular p*2(x)
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Calcular p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades de Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Calcular fs(x)
for (i in 1:(n + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 20)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Crear el data.frame con n+1 filas
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1, ncol = length(columnas)))
colnames(df_convolucion) <- columnas
# Llenar el dataframe
df_convolucion[["x"]] <- 0:n
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, n))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Calcular p*2(x)
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Calcular p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades de Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Calcular fs(x)
for (i in 1:(n + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 20)
print(pepe)
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Crear el data.frame con n+1 filas
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1, ncol = length(columnas)))
colnames(df_convolucion) <- columnas
# Llenar el dataframe
df_convolucion[["x"]] <- 0:n
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, n))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Calcular p*2(x)
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Calcular p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades de Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Calcular fs(x)
for (i in 1:(n + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
print(pepe)
setwd("C:/Users/AMADOR/OneDrive - Universidad de Costa Rica/I-2025/Seguros de no-vida/Tarea 3 Seguros no vida")
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
combinacion_suma <- function(vec1, vec2, indice_df) { #donde x es indice
suma <- 0
if (indice_df == 0) {
suma <- vec1[1] * vec2[1]
return(suma)
}
else {
for (i in 0:indice_df) {
suma <- suma + vec1[1 + i] * vec2[(indice_df + 1) - i]
}
return(suma)
}
}
convoluciador <- function(vec_conv1, vec_conv2){
# Creación de vector para guardar los resultados de los productos
vec_nueva_conv <- vector(mode = "numeric", length = length(vec_conv1))
for (i in 1:length(vec_conv1)) {
indice= i-1
vec_nueva_conv[i] <- combinacion_suma(vec_conv1, vec_conv2, indice)
}
return(vec_nueva_conv)
}
metodo_basico <- function(lambda, prob_montos, max_num_reclamos) {
n <- max_num_reclamos
# Crear nombres de columnas
columnas <- c("x", "p*0(x)", "p(x)", paste0("p*", 2:n, "(x)"), "fs(x)")
# Crear el data.frame con n+1 filas
df_convolucion <- as.data.frame(matrix(0, nrow = n + 1, ncol = length(columnas)))
colnames(df_convolucion) <- columnas
# Llenar el dataframe
df_convolucion[["x"]] <- 0:n
prob_montos <- c(0, prob_montos)
df_convolucion[["p*0(x)"]] <- c(1, rep(0, n))  # p*0(x)
df_convolucion[["p(x)"]][1:length(prob_montos)] <- prob_montos  # p(x)
# Calcular p*2(x)
df_convolucion[["p*2(x)"]] <- convoluciador(df_convolucion[[3]], df_convolucion[[3]])
# Calcular p*3(x), ..., p*n(x)
for (i in 5:(n + 2)) {
a <- i - 1
df_convolucion[[i]] <- convoluciador(df_convolucion[[3]], df_convolucion[[a]])
}
# Vector de probabilidades de Poisson(lambda)
vec_prob_N <- sapply(0:n, function(i) dpois(i, lambda))
# Calcular fs(x)
for (i in 1:(n + 1)) {
v <- as.numeric(df_convolucion[i, ])
v_sin_extremos <- v[-c(1, length(v))]  # Quitamos x y fs(x)
df_convolucion[["fs(x)"]][i] <- sum(v_sin_extremos * vec_prob_N)
}
return(df_convolucion)
}
# Llamar correctamente a la función
pepe <- metodo_basico(lambda = 0.8, prob_montos = c(0.25,0.375, 0.375), max_num_reclamos = 6)
print(pepe)
